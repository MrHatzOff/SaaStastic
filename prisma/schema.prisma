generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String           @id @default(cuid())
  email       String           @unique
  name        String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  deletedAt   DateTime?
  logs        EventLog[]
  feedback    Feedback[]
  companies   UserCompany[]
  invitations UserInvitation[]

  @@index([email])
  @@index([deletedAt])
}

model Company {
  id                   String           @id @default(cuid())
  name                 String
  slug                 String           @unique
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  deletedAt            DateTime?
  createdBy            String?
  updatedBy            String?
  stripeCustomerId     String?          @unique
  stripeSubscriptionId String?          @unique
  customers            Customer[]
  eventLogs            EventLog[]
  feedbacks            Feedback[]
  invoices             Invoice[]
  paymentMethods       PaymentMethod[]
  subscription         Subscription?
  usageRecords         UsageRecord[]
  users                UserCompany[]
  invitations          UserInvitation[]
  roles                RoleModel[]

  @@index([slug])
  @@index([deletedAt])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

model UserCompany {
  id        String     @id @default(cuid())
  userId    String
  companyId String
  role      Role       @default(MEMBER)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  createdBy String?
  updatedBy String?
  roleId    String?
  company   Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  roleRef   RoleModel? @relation(fields: [roleId], references: [id])
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, companyId])
  @@index([companyId])
  @@index([userId])
  @@index([roleId])
}

model Customer {
  id        String    @id @default(cuid())
  name      String
  email     String?
  phone     String?
  notes     String?
  companyId String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  createdBy String?
  updatedBy String?
  company   Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([email])
  @@index([deletedAt])
  @@index([companyId, createdAt])
}

model EventLog {
  id        String   @id @default(cuid())
  action    String
  metadata  Json?
  userId    String
  companyId String
  createdAt DateTime @default(now())
  ipAddress String?
  userAgent String?
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@index([companyId, createdAt])
}

model Feedback {
  id        String   @id @default(cuid())
  message   String
  rating    Int?
  userId    String
  companyId String
  createdAt DateTime @default(now())
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([userId])
  @@index([createdAt])
  @@index([companyId, createdAt])
}

model Subscription {
  id                   String             @id @default(cuid())
  companyId            String             @unique
  stripeSubscriptionId String             @unique
  stripePriceId        String
  stripeProductId      String
  status               SubscriptionStatus
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  canceledAt           DateTime?
  trialStart           DateTime?
  trialEnd             DateTime?
  metadata             Json?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  createdBy            String?
  updatedBy            String?
  company              Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([stripeSubscriptionId])
  @@index([status])
  @@index([currentPeriodEnd])
}

model Invoice {
  id               String        @id @default(cuid())
  companyId        String
  stripeInvoiceId  String        @unique
  invoiceNumber    String?
  amountDue        Int
  amountPaid       Int
  currency         String        @default("usd")
  status           InvoiceStatus
  dueDate          DateTime?
  paidAt           DateTime?
  periodStart      DateTime
  periodEnd        DateTime
  invoicePdf       String?
  hostedInvoiceUrl String?
  metadata         Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  company          Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([stripeInvoiceId])
  @@index([status])
  @@index([createdAt])
  @@index([companyId, createdAt])
}

model PaymentMethod {
  id                    String   @id @default(cuid())
  companyId             String
  stripePaymentMethodId String   @unique
  type                  String
  card                  Json?
  isDefault             Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  createdBy             String?
  updatedBy             String?
  company               Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([stripePaymentMethodId])
  @@index([isDefault])
}

model UsageRecord {
  id        String   @id @default(cuid())
  companyId String
  metric    String
  quantity  Int
  timestamp DateTime @default(now())
  metadata  Json?
  createdAt DateTime @default(now())
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([metric])
  @@index([timestamp])
  @@index([companyId, metric, timestamp])
}

model UserInvitation {
  id         String     @id @default(cuid())
  email      String
  companyId  String
  role       Role       @default(MEMBER)
  token      String     @unique
  expiresAt  DateTime
  acceptedAt DateTime?
  invitedBy  String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  roleId     String?
  company    Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  inviter    User       @relation(fields: [invitedBy], references: [id], onDelete: Cascade)
  roleRef    RoleModel? @relation("InvitationRole", fields: [roleId], references: [id])

  @@unique([email, companyId])
  @@index([companyId])
  @@index([token])
  @@index([email])
  @@index([expiresAt])
  @@index([roleId])
}

model Permission {
  id          String      @id @default(cuid())
  key         String      @unique
  name        String
  description String?
  category    String
  isSystem    Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  roles       RoleModel[] @relation("RolePermissions")

  @@index([category])
  @@index([isSystem])
  @@map("permissions")
}

model RoleModel {
  id            String           @id @default(cuid())
  name          String
  description   String?
  isSystem      Boolean          @default(false)
  companyId     String
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  createdBy     String?
  updatedBy     String?
  slug          String
  userCompanies UserCompany[]
  invitations   UserInvitation[] @relation("InvitationRole")
  company       Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  permissions   Permission[]     @relation("RolePermissions")

  @@unique([name, companyId])
  @@unique([slug, companyId])
  @@index([companyId])
  @@index([isSystem])
  @@map("roles")
}

enum Role {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAST_DUE
  TRIALING
  UNPAID
  PAUSED
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PAID
  UNCOLLECTIBLE
  VOID
}

// ===================================
// SAASTASTIC LICENSE MANAGEMENT
// For tracking customers who purchase SaaStastic boilerplate
// ===================================

enum LicenseTier {
  STARTER      // $399 - 1 project, community support
  PROFESSIONAL // $997 - 1 project, 30 days email support
  AGENCY       // $4,997 - Unlimited projects, priority support
  ENTERPRISE   // $9,997/year - White-label, 24hr SLA
  FOREVER      // $20,000 - Lifetime everything
}

model LicenseCustomer {
  id                String       @id @default(cuid())
  email             String       @unique
  name              String?
  tier              LicenseTier
  licenseKey        String       @unique
  githubUsername    String?
  
  // Purchase tracking
  purchaseDate      DateTime     @default(now())
  renewalDate       DateTime?    // For Enterprise subscriptions
  expiresAt         DateTime?    // When license expires (null = forever)
  
  // Support tracking
  supportHours      Int          @default(0)  // Remaining support hours
  supportExpiresAt  DateTime?    // When support hours expire
  
  // Payment tracking
  lemonSqueezyOrderId      String?  @unique
  lemonSqueezyCustomerId   String?
  lemonSqueezySubscriptionId String? @unique
  lemonSqueezyLicenseKey   String?  @unique  // LS auto-generated key (XXXX-XXXX-XXXX-XXXX)
  
  // Status
  isActive          Boolean      @default(true)
  isCancelled       Boolean      @default(false)
  cancelledAt       DateTime?
  
  // Metadata
  metadata          Json?        // Store additional info (custom fields, notes, etc.)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  // Relations
  supportSessions   SupportSession[]
  
  @@index([email])
  @@index([tier])
  @@index([licenseKey])
  @@index([isActive])
  @@index([lemonSqueezyOrderId])
  @@index([lemonSqueezyCustomerId])
  @@index([lemonSqueezyLicenseKey])
}

model SupportSession {
  id                String          @id @default(cuid())
  licenseCustomerId String
  
  // Session details
  scheduledAt       DateTime
  completedAt       DateTime?
  durationMinutes   Int             @default(60)
  hoursUsed         Int             @default(1) // How many hours this consumed
  
  // Session content
  topic             String?
  notes             String?
  recording         String?         // URL to recording if applicable
  
  // Status
  status            SupportStatus   @default(SCHEDULED)
  
  // Metadata
  metadata          Json?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  customer          LicenseCustomer @relation(fields: [licenseCustomerId], references: [id], onDelete: Cascade)
  
  @@index([licenseCustomerId])
  @@index([scheduledAt])
  @@index([status])
}

enum SupportStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  NO_SHOW
}
